// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

type EnvSource = Record<string, string | undefined>;

declare const __SUPABASE_ENV__:
  | (EnvSource & {
      VITE_SUPABASE_URL?: string;
      VITE_SUPABASE_PUBLISHABLE_KEY?: string;
      VITE_SUPABASE_ANON_KEY?: string;
      VITE_SUPABASE_KEY?: string;
      VITE_SUPABASE_PUBLIC_KEY?: string;
      VITE_SUPABASE_MANAGED_CUSTOM_DOMAIN?: string;
    })
  | undefined;

const loadBundlerEnv = (): EnvSource | undefined => {
  if (typeof __SUPABASE_ENV__ !== 'undefined' && __SUPABASE_ENV__ !== null) {
    return __SUPABASE_ENV__;
  }

  if (typeof globalThis !== 'undefined' && '__SUPABASE_ENV__' in globalThis) {
    const globalEnv = (globalThis as typeof globalThis & { __SUPABASE_ENV__?: EnvSource }).__SUPABASE_ENV__;
    if (globalEnv) {
      return globalEnv;
    }
  }

  return undefined;
};
const loadImportMetaEnv = (): EnvSource | undefined => {
  return typeof import.meta !== 'undefined'
    ? ((import.meta as ImportMeta & { env?: EnvSource })?.env ?? undefined)
    : undefined;
};

const processEnv = typeof process !== 'undefined'
  ? ((process.env ?? {}) as EnvSource)
  : undefined;

const envSource: EnvSource = loadBundlerEnv() ?? loadImportMetaEnv() ?? processEnv ?? {};

const DEFAULT_SUPABASE_URL = 'http://localhost:54321';
const DEFAULT_SUPABASE_PUBLISHABLE_KEY = 'public-anon-key';
const DEFAULT_SUPABASE_PROJECT_ID = 'default';

const normalizeEnvValue = (value: string | undefined) => (typeof value === 'string' ? value.trim() : undefined);
const normalizeBooleanEnvValue = (value: string | undefined) => {
  const normalized = normalizeEnvValue(value);
  if (!normalized) {
    return false;
  }

  return /^(1|true|t|yes|y|on)$/i.test(normalized);
};

const SUPABASE_PROJECT_ID = normalizeEnvValue(envSource.VITE_SUPABASE_PROJECT_ID) ?? DEFAULT_SUPABASE_PROJECT_ID;
const SUPABASE_BASE_URL_ENV = normalizeEnvValue(envSource.VITE_SUPABASE_URL);
const SUPABASE_BASE_URL = SUPABASE_BASE_URL_ENV ?? DEFAULT_SUPABASE_URL;
const LOCAL_HOSTNAMES = new Set(['localhost', '127.0.0.1', '::1']);
const SUPABASE_MANAGED_CUSTOM_DOMAIN = normalizeBooleanEnvValue(
  envSource.VITE_SUPABASE_MANAGED_CUSTOM_DOMAIN,
);

const shouldAppendProjectPath = (url: URL) => {
  if (LOCAL_HOSTNAMES.has(url.hostname)) {
    return false;
  }

  if (url.hostname.endsWith('.supabase.co') || url.hostname.endsWith('.supabase.in')) {
    return false;
  }

  if (
    SUPABASE_MANAGED_CUSTOM_DOMAIN &&
    (!url.port || url.port === '80' || url.port === '443')
  ) {
    return false;
  }

  const pathname = url.pathname;
  return !/\/project\//.test(pathname) && !/\/projects\//.test(pathname);
};

const buildSupabaseUrl = (baseUrl: string, projectId?: string) => {
  try {
    const parsedUrl = new URL(baseUrl);
    if (projectId && shouldAppendProjectPath(parsedUrl)) {
      const trimmedPath = parsedUrl.pathname.endsWith('/')
        ? parsedUrl.pathname.slice(0, -1)
        : parsedUrl.pathname;
      parsedUrl.pathname = `${trimmedPath}/project/${projectId}`.replace('//', '/');
      return parsedUrl.toString().replace(/\/$/, '');
    }
    return parsedUrl.toString().replace(/\/$/, '');
  } catch {
    return baseUrl;
  }
};

const SUPABASE_URL = buildSupabaseUrl(SUPABASE_BASE_URL, SUPABASE_PROJECT_ID);
const SUPABASE_KEY_SOURCES = [
  envSource.VITE_SUPABASE_PUBLISHABLE_KEY,
  envSource.VITE_SUPABASE_ANON_KEY,
  envSource.VITE_SUPABASE_KEY,
  envSource.VITE_SUPABASE_PUBLIC_KEY,
];

const SUPABASE_NORMALIZED_KEYS = SUPABASE_KEY_SOURCES.map(normalizeEnvValue);
const SUPABASE_RESOLVED_KEY = SUPABASE_NORMALIZED_KEYS.find((value): value is string => typeof value === 'string');

const SUPABASE_CONFIGURATION_ERROR_MESSAGE =
  'Configure VITE_SUPABASE_URL e VITE_SUPABASE_ANON_KEY no arquivo .env.';

const SUPABASE_INITIALIZATION_ERROR =
  !SUPABASE_BASE_URL_ENV || !SUPABASE_RESOLVED_KEY
    ? new Error(SUPABASE_CONFIGURATION_ERROR_MESSAGE)
    : undefined;

const SUPABASE_PUBLISHABLE_KEY = SUPABASE_RESOLVED_KEY ?? DEFAULT_SUPABASE_PUBLISHABLE_KEY;

const authStorage = typeof window !== 'undefined' && window?.localStorage ? window.localStorage : undefined;

type SupabaseClientInstance = ReturnType<typeof createClient<Database>>;

const globalSupabase = globalThis as typeof globalThis & { __supabaseClient__?: SupabaseClientInstance };

if (!globalSupabase.__supabaseClient__ && !SUPABASE_INITIALIZATION_ERROR) {
  globalSupabase.__supabaseClient__ = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
    auth: {
      storage: authStorage,
      persistSession: true,
      autoRefreshToken: true,
    },
    global: {
      headers: {
        apikey: SUPABASE_PUBLISHABLE_KEY,
      },
    },
  });
}

const supabaseInstance = globalSupabase.__supabaseClient__;

const createErrorProxy = <T extends object>(error: Error) =>
  new Proxy(
    {},
    {
      get() {
        throw error;
      },
    },
  ) as T;

const supabase = SUPABASE_INITIALIZATION_ERROR
  ? createErrorProxy<SupabaseClientInstance>(SUPABASE_INITIALIZATION_ERROR)
  : (supabaseInstance as SupabaseClientInstance);

const supabaseFunctions = SUPABASE_INITIALIZATION_ERROR ? undefined : supabase.functions;

if (supabaseFunctions?.invoke) {
  const originalInvoke = supabaseFunctions.invoke.bind(supabaseFunctions);

  supabaseFunctions.invoke = (async (functionName, options) => {
    const { data } = await supabase.auth.getSession();
    const accessToken = data?.session?.access_token;

    const headers = accessToken
      ? { ...(options?.headers ?? {}), Authorization: `Bearer ${accessToken}` }
      : options?.headers;

    return originalInvoke(functionName, {
      ...(options ?? {}),
      ...(headers ? { headers } : {}),
    });
  }) as typeof supabaseFunctions.invoke;
}

export { supabase };
export const supabaseInitializationError = SUPABASE_INITIALIZATION_ERROR;
